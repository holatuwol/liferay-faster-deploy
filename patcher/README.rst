Installation
============

Clone this repository.

.. code-block:: bash

	git clone git@github.com:holatuwol/liferay-faster-deploy.git

Make sure that you've got all the prerequisite binary tools and Python packages:

* `Initial Setup <../SETUP.rst>`__

Then, add this section to ``.bash_aliases`` (or the equivalent on whichever shell you're using) which calls the script, making sure to change ``/path/to/clone/location`` to wherever you cloned the repository:

.. code-block:: bash

	MCD_RD_CLONE_PATH=/path/to/clone/location

	findbuild() {
		FILES_MIRROR=http://mirrors/files.liferay.com \
			FILES_EE_FOLDER=private/ee \
			${MCD_RD_CLONE_PATH}/patcher/findbuild $@
	}

	fixlist62() {
		FILES_MIRROR=http://mirrors/files.liferay.com \
			${MCD_RD_CLONE_PATH}/patcher/fixlist62 $@
	}

	patcher() {
		${MCD_RD_CLONE_PATH}/patcher/patcher $@
	}

	scouthotfix() {
		${MCD_RD_CLONE_PATH}/patcher/scouthotfix $@
	}

	subrepobp() {
		SUBREPO_ROOT=/path/to/subrepo/root \
			${MCD_RD_CLONE_PATH}/patcher/subrepobp $@
	}

	testray() {
		FILES_MIRROR=http://mirrors/files.liferay.com \
			${MCD_RD_CLONE_PATH}/patcher/testray $@
	}

Scout Hotfix
============

Build a Docker image with the hotfix installed and then run ``docker scout sbom`` to see if all the versions that you were trying to update were properly updated.

* `scouthotfix <scouthotfix>`__

Navigate to the folder containing the hotfix and run the command. Make sure to download the appropriate version of Patching Tool to the same folder as well.


Find Build for Hotfix
=====================

If you have a hotfix, you might want to be able to find the build corresponding to that hotfix, whether for purposes of checking it out locally using the automatically generated tag or simply to see what fixes it included. This script opens a web browser to the build in patcher portal.

* `findbuild <findbuild>`__

You can use it by specifying the hotfix number followed by the version of Liferay. For example, if you want to load hotfix 1 for 7010, you would use any of the following commands.

.. code-block:: bash

	findbuild 1 7010
	findbuild hotfix-1-7010
	findbuild liferay-hotfix-1-7010

Find Unique Fixes in Hotfix
===========================

Because of the way patcher portal works, it's possible for customer support engineers to generate fixes that include fix names that are already part of a portal fix. While patcher portal can resolve this noise on its own, it still creates a lot of noise for technical support engineers if you need fixes to be rebased on a new portal fixpack level.

You can use this script to only list the unique LPEs that don't already exist in a portal fixpack.

.. code-block:: bash

	fixlist62 portal-123 'LPE-1234,LPE-5678,LPE-9012'


Add New Fixes
=============

You might want to create a new fix inside of patcher portal. This script ensures that all the fix baselines used in patcher portal (or at least, the ones that I remember to update in an S3 bucket) are available out locally, double-checks to make sure that you haven't modified any files that would cause your fix to get rejected (such as ``packageinfo`` updates or ``bnd.bnd`` updates that modify a version), and opens your web browser to the fix creation page.

* `patcher <patcher>`__

If you don't specify any parameters, it will try to guess the fix name based on your current branch name, or the current history of commits, relative to the baseline. If you do specify parameters, you can either specify an existing fix ID, or you can specify a list of tickets.

.. code-block:: bash

	patcher
	patcher 1
	patcher LPS-91846, LPS-93486, LPS-93497, LPS-94011

It uses the `patcher.json <patcher.json>`__ file stored in your clone of this Git repository, which is generated by visiting patcher portal with a Bookmarklet with the code described in `patcher.js <patcher.js>`__.

* `Bookmarklet Creator <http://mrcoles.com/bookmarklet/>`__

Right now, patcher has a defect where it doesnâ€™t know what to do with the URL parameter for the baseline ID the version is 2 (in other words, 7.0.x and later fixes). In order to work around this defect, you can use a Bookmarklet. Just paste the Javascript into the Bookmarklet Creator and add the result as a bookmarklet in your Bookmarks bar and click on it after Patcher Portal loads.

.. code-block:: javascript

	var selectName = '_1_WAR_osbpatcherportlet_patcherProjectVersionId';
	var select = AUI().one('#' + selectName);

	var re = new RegExp(selectName + '=(\\d+)');
	var match = re.exec(document.location.search);

	if (match) {
		var id = match[1];
		var option = select.one('option[value="' + id + '"]');

		if (option) {
			option.set('selected', true);
		}
	}

Backport Subrepository Changes
==============================

Before adding a fix to patcher portal, it's desirable to first backport the fix onto the ``ee-7.0.x`` branch so that you can cherry pick the commit into your main branch. While this is pretty easy for changes coming from the central repository using tools like `backport automator <https://github.com/jonathanmccann/backport-automator>`__, it's less easy for changes coming from subrepositories.

This script captures the commits within each subrepository where the log messages match a specific pattern, most likely an LPS ticket (``git log --grep``). It rewrites the patch files so that they can be applied to ``ee-7.0.x``, and as long as the portal source is currently at ``ee-7.0.x``, it then creates a new branch then attempts to apply the changes to ``ee-7.0.x`` using ``git am``.

* `subrepobp <subrepobp>`__

To use this script, run it from a folder that currently has ``ee-7.0.x`` checked out or a DE baseline tag checked out. Then, list all of the tickets that you wish to backport from the subrepository. This does not yet search for dependencies; it simply searches the logs for the specified tickets and brings them in order.

.. code-block:: bash

	subrepobp LPS-1 LPS-2 LPS-3 LPS-4

Lookup Build Result on Testray
==============================

While doing Support QA work, I realized that I really disliked how I had to travel through so many different screens in order to get to the build results. So, I decided to automate that part of it.

* `testray <testray>`__

In order to use this script, you'll want to set the ``id`` for the 1password entry for your liferay.com Okta login details to the git property ``1password.liferay``. If you're not sure what the ``id`` is but you do know what its ``name`` is (it shows up in the 1Password UI), you can set it using the following command, replacing "OKTA - Your Name" with the appropriate ``name``:

.. code-block:: bash

	git config --global 1password.liferay "$(op item get --format json "OKTA - Your Name" | jq -r '.id')"

Once you've done that, just give it the name of a fix pack, a Patcher Portal build URL, or a hotfix URL.

.. code-block:: bash

	testray fix-pack-de-1-7010
	testray https://patcher.liferay.com/group/guest/patching/-/osb_patcher/builds/0
	testray http://files.liferay.com/private/ee/fix-packs/7.0.10/hotfix/liferay-hotfix-0-7010.zip

You can also specify multiple values as arguments, where the first argument will be chosen as a reference build, and all other builds will be compared to that build.

You can also specify no arguments at all, and it will query patcher portal to find all builds that require QA analysis, and then run the script as though you were asking for each build one at a time (this means it uses the standard approach for comparisons).

If no information is found on Testray, this script will attempt to open a browser window (or multiple browser windows) to Jenkins. If automated testing has started, the browser window will point to the currently running job on Jenkins corresponding to those tests. If automated testing has not started (for example, the build is still compiling), this will instead open all build URLs for the build so you can check past build statuses.